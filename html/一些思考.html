<!DOCTYPE html><html lang=en><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=date content="2023/03/03 21:50"><title>一些思考</title><link rel=stylesheet href=/style/air.css><link rel=stylesheet href=/style/article.css><link rel=stylesheet href=/style/highlight.agate.css><link rel="shortcut icon"href=/favicon.ico type=image/x-icon><script async src="//www.googletagmanager.com/gtag/js?id=G-EHZ8V74593"></script><script async src=//bucket2023.oss-cn-hangzhou.aliyuncs.com/javascript/qrcode.min.js></script><script async src=//bucket2023.oss-cn-hangzhou.aliyuncs.com/javascript/FileSaver.min.js></script><script src=//bucket2023.oss-cn-hangzhou.aliyuncs.com/javascript/Valine.min.js></script><script src=//bucket2023.oss-cn-hangzhou.aliyuncs.com/javascript/highlight.min.js></script><script src=//bucket2023.oss-cn-hangzhou.aliyuncs.com/javascript/canvas-toBlob.js></script><script src=//bucket2023.oss-cn-hangzhou.aliyuncs.com/javascript/vconsole.min.js></script><script src=//bucket2023.oss-cn-hangzhou.aliyuncs.com/javascript/html-to-image.js></script><main id=content><h1>一些思考</h1><p>本周偶然的机会又重新了解了下以前在 React 开发中使用到的状态管理工具 Mobx,之前只是将它和 React 结合起来使用，Mobx 处理状态管理方面的事情，通过使用 mobx-react，可以让 React 组件具备和 Vue（MVVM 模式）组件一样双向绑定的效果，当状态发生改变，UI 自动更新，React 则解决 UI 层的问题，提供了 JSX 语法糖和组件化（生命周期）的处理能力。除此之外并没有单独使用 Mobx 的场景。于是私下里自己使用原生的 HTML+JS 结合 Mobx 写一个 todolist，这时候才发现使用三方库和框架的带来的好处，因为原生自己写，就会写很多的 createElement 和 addEventListener 的逻辑，尽管是拿 web-component 来写也避免不了对原生 dom 的操作（都说操作原生 dom 的代价是高昂的，但是其实数据量不大，页面结构不那么复杂的时候，操作 dom 的成本并感知不到），但是如果采用第三方库或者框架，比如 React 或者 Vue,就会简单的多，框架帮开发者抹平了大量的调用原生 API 的事情，使用 React 你只要熟悉 JSX 语法和 React 的生命周期钩子就行了，写 Vue 更简单，写模板的过程基本是和 HTML 平滑过度的，而只要简单知道一些 Vue 的 api 和生命周期钩子就可以上手开发，大大的降低了开发的门槛和成本，从编码的角度上也可以说是很大程度上提升了效率，尤其是对于复杂度比较高的应用来说,而且了两者都引入了虚拟 DOM 的概念。<p>我在写 todolist 的过程中，最初的实现非常暴力，就是通过 Mobx 的 autorun 处理数据状态的变化，然后全量重渲染 dom 节点（先卸载，再创建，再挂载），这种简单粗暴的方式对于复杂度不高，数据量不大(哪怕数据量上升到万级)的 list 完全没问题（卸载再挂载耗时也就 300ms 以内），而且又是纯原生，丝毫感受不到任何性能上的卡顿，但是一旦数量级(10 万级)上去（3000ms 开外了），需要大量的卸载和重新创建挂载 dom 的时候，就开始出现卡顿了，也就自然而然的考虑到了优化，引入了虚拟 DOM、diff 算法、生命周期的概念，这个时候上库或者框架就是不二之选了。<p>其实如果要从性能的角度考虑，原生是最没有性能负担的（除了内存泄露外），但是一旦应用的复杂度上升，原生开发重量级的应用就显得捉襟见肘了（复用、模块化、工程化、后期维护等），但是现在很多从业者都是一开始就从库或者框架学起的（包括我本人，也是入行后边做边学的基础，最开始接触的也是库 —— React），从最开始的输入侧就没有接受到足够的原生底层 API 的训练，直接上来就是抹平了底层 API 调用的框架 API，以至于有一些不复杂、轻量化、短期化的单页或者 H5 都要用框架去开发，反而得不偿失。<p>这次编码过程带给我最大的收获就是：<p>Mobx 是一个非常轻量和可扩展的状态管理库，及时不合任何其他框架搭配使用，依然非常优秀<p>对于原生和框架之间的关系有了更进一步的认识，框架出现解决的是什么问题，有什么优势，原生的瓶颈在哪里，以及所谓的操作 DOM 的代价高昂在哪里<p>对于学习有了更进一步的感悟，总会经历一个环形的迭代过程，认知 -> 使用 -> 迷惑 -> 思考 -> 实验 -> 理解 -> 新的认知 -> ……<p>分层架构设计的理解，MV*模式在 GUI 领域的运用以及其解决的什么问题（数据变化&视图同步），以及演进过程</main><div class=backicon></div><div class=qrcodes><div><img class=zhifubao src=/assets/images/%E6%94%AF%E4%BB%98%E5%AE%9D.jpg alt=支付宝 width=200 height=200> <label style=font-size:small>支付宝</label></div><div><img class=wechat src=/assets/images/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE.jpg alt=微信收款 width=200 height=200> <label style=font-size:small>微信</label></div></div><p style=text-align:center;font-size:smaller;color:#777;margin-top:4rem>“觉得不错，买杯奶茶给作者吧”<section id=extra><div class=qrcodeicon></div><div class=shareicon></div><div id=vcomments></div></section><script src=/js/article.js></script>
---
title: 一些思考
subtitle: 使用Mobx
intro: 使用原生和框架之间的一些思考
date: 2023/03/03 21:50
---

# 一些思考

本周偶然的机会又重新了解了下以前在 React 开发中使用到的状态管理工具 Mobx,之前只是将它和 React 结合起来使用，Mobx 处理状态管理方面的事情，通过使用 mobx-react，可以让 React 组件具备和 Vue（MVVM 模式）组件一样双向绑定的效果，当状态发生改变，UI 自动更新，React 则解决 UI 层的问题，提供了 JSX 语法糖和组件化（生命周期）的处理能力。除此之外并没有单独使用 Mobx 的场景。于是私下里自己使用原生的 HTML+JS 结合 Mobx 写一个 todolist，这时候才发现使用三方库和框架的带来的好处，因为原生自己写，就会写很多的 createElement 和 addEventListener 的逻辑，尽管是拿 web-component 来写也避免不了对原生 dom 的操作（都说操作原生 dom 的代价是高昂的，但是其实数据量不大，页面结构不那么复杂的时候，操作 dom 的成本并感知不到），但是如果采用第三方库或者框架，比如 React 或者 Vue,就会简单的多，框架帮开发者抹平了大量的调用原生 API 的事情，使用 React 你只要熟悉 JSX 语法和 React 的生命周期钩子就行了，写 Vue 更简单，写模板的过程基本是和 HTML 平滑过度的，而只要简单知道一些 Vue 的 api 和生命周期钩子就可以上手开发，大大的降低了开发的门槛和成本，从编码的角度上也可以说是很大程度上提升了效率，尤其是对于复杂度比较高的应用来说,而且了两者都引入了虚拟 DOM 的概念。

我在写 todolist 的过程中，最初的实现非常暴力，就是通过 Mobx 的 autorun 处理数据状态的变化，然后全量重渲染 dom 节点（先卸载，再创建，再挂载），这种简单粗暴的方式对于复杂度不高，数据量不大(哪怕数据量上升到万级)的 list 完全没问题（卸载再挂载耗时也就 300ms 以内），而且又是纯原生，丝毫感受不到任何性能上的卡顿，但是一旦数量级(10 万级)上去（3000ms 开外了），需要大量的卸载和重新创建挂载 dom 的时候，就开始出现卡顿了，也就自然而然的考虑到了优化，引入了虚拟 DOM、diff 算法、生命周期的概念，这个时候上库或者框架就是不二之选了。

其实如果要从性能的角度考虑，原生是最没有性能负担的（除了内存泄露外），但是一旦应用的复杂度上升，原生开发重量级的应用就显得捉襟见肘了（复用、模块化、工程化、后期维护等），但是现在很多从业者都是一开始就从库或者框架学起的（包括我本人，也是入行后边做边学的基础，最开始接触的也是库 —— React），从最开始的输入侧就没有接受到足够的原生底层 API 的训练，直接上来就是抹平了底层 API 调用的框架 API，以至于有一些不复杂、轻量化、短期化的单页或者 H5 都要用框架去开发，反而得不偿失。

这次编码过程带给我最大的收获就是：

Mobx 是一个非常轻量和可扩展的状态管理库，及时不合任何其他框架搭配使用，依然非常优秀

对于原生和框架之间的关系有了更进一步的认识，框架出现解决的是什么问题，有什么优势，原生的瓶颈在哪里，以及所谓的操作 DOM 的代价高昂在哪里

对于学习有了更进一步的感悟，总会经历一个环形的迭代过程，认知 -> 使用 -> 迷惑 -> 思考 -> 实验 -> 理解 -> 新的认知 -> ……

分层架构设计的理解，MV\*模式在 GUI 领域的运用以及其解决的什么问题（数据变化&视图同步），以及演进过程
